"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getLogger = exports.invokeNew = exports.wrapAngularDevkitSchematic = exports.runMigration = exports.generate = exports.NxScopedHostForMigrations = exports.NxScopedHost = exports.run = void 0;
const tslib_1 = require("tslib");
const architect_1 = require("@angular-devkit/architect");
const node_1 = require("@angular-devkit/architect/node");
const core_1 = require("@angular-devkit/core");
const chalk = require("chalk");
const node_2 = require("@angular-devkit/core/node");
const tools_1 = require("@angular-devkit/schematics/tools");
const schematics_1 = require("@angular-devkit/schematics");
const fs_1 = require("fs");
const package_manager_1 = require("@nrwl/tao/src/shared/package-manager");
const workspace_1 = require("@nrwl/tao/src/shared/workspace");
const workflow_1 = require("@angular-devkit/schematics/src/workflow");
const options_1 = require("@angular-devkit/schematics/tasks/package-manager/options");
const node_3 = require("@angular-devkit/schematics/tasks/node");
const path_1 = require("path");
const stripJsonComments = require("strip-json-comments");
const operators_1 = require("rxjs/operators");
const logger_1 = require("../shared/logger");
function run(root, opts, verbose) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const logger = exports.getLogger(verbose);
        const fsHost = new NxScopedHost(core_1.normalize(root));
        const { workspace } = yield core_1.workspaces.readWorkspace(workspace_1.workspaceConfigName(root), core_1.workspaces.createWorkspaceHost(fsHost));
        const registry = new core_1.json.schema.CoreSchemaRegistry();
        registry.addPostTransform(core_1.schema.transforms.addUndefinedDefaults);
        const architectHost = new node_1.WorkspaceNodeModulesArchitectHost(workspace, root);
        const architect = new architect_1.Architect(architectHost, registry);
        const run = yield architect.scheduleTarget({
            project: opts.project,
            target: opts.target,
            configuration: opts.configuration,
        }, opts.runOptions, { logger });
        const result = yield run.output.toPromise();
        yield run.stop();
        return result.success ? 0 : 1;
    });
}
exports.run = run;
function createWorkflow(fsHost, root, opts) {
    const workflow = new tools_1.NodeWorkflow(fsHost, {
        force: opts.force,
        dryRun: opts.dryRun,
        packageManager: package_manager_1.detectPackageManager(),
        root: core_1.normalize(root),
        registry: new core_1.schema.CoreSchemaRegistry(schematics_1.formats.standardFormats),
        resolvePaths: [process.cwd(), root],
    });
    workflow.registry.addPostTransform(core_1.schema.transforms.addUndefinedDefaults);
    workflow.engineHost.registerOptionsTransform(tools_1.validateOptionsWithSchema(workflow.registry));
    return workflow;
}
function getCollection(workflow, name) {
    const collection = workflow.engine.createCollection(name);
    if (!collection)
        throw new Error(`Cannot find collection '${name}'`);
    return collection;
}
function createRecorder(record, logger) {
    return (event) => {
        const eventPath = event.path.startsWith('/')
            ? event.path.substr(1)
            : event.path;
        if (event.kind === 'error') {
            record.error = true;
            logger.warn(`ERROR! ${eventPath} ${event.description == 'alreadyExist'
                ? 'already exists'
                : 'does not exist.'}.`);
        }
        else if (event.kind === 'update') {
            record.loggingQueue.push(core_1.tags.oneLine `${chalk.white('UPDATE')} ${eventPath} (${event.content.length} bytes)`);
        }
        else if (event.kind === 'create') {
            record.loggingQueue.push(core_1.tags.oneLine `${chalk.green('CREATE')} ${eventPath} (${event.content.length} bytes)`);
        }
        else if (event.kind === 'delete') {
            record.loggingQueue.push(`${chalk.yellow('DELETE')} ${eventPath}`);
        }
        else if (event.kind === 'rename') {
            record.loggingQueue.push(`${chalk.blue('RENAME')} ${eventPath} => ${event.to}`);
        }
    };
}
function runSchematic(root, workflow, logger, opts, schematic, printDryRunMessage = true, recorder = null) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const record = { loggingQueue: [], error: false };
        workflow.reporter.subscribe(recorder || createRecorder(record, logger));
        try {
            yield workflow
                .execute({
                collection: opts.collectionName,
                schematic: opts.generatorName,
                options: opts.generatorOptions,
                debug: opts.debug,
                logger,
            })
                .toPromise();
        }
        catch (e) {
            console.log(e);
            throw e;
        }
        if (!record.error) {
            record.loggingQueue.forEach((log) => logger.info(log));
        }
        if (opts.dryRun && printDryRunMessage) {
            logger.warn(`\nNOTE: The "dryRun" flag means no changes were made.`);
        }
        return { status: 0, loggingQueue: record.loggingQueue };
    });
}
class MigrationEngineHost extends tools_1.NodeModulesEngineHost {
    constructor(logger) {
        super();
        this.nodeInstallLogPrinted = false;
        // Overwrite the original CLI node package executor with a new one that does basically nothing
        // since nx migrate doesn't do npm installs by itself
        // (https://github.com/angular/angular-cli/blob/5df776780deadb6be5048b3ab006a5d3383650dc/packages/angular_devkit/schematics/tools/workflow/node-workflow.ts#L41)
        this.registerTaskExecutor({
            name: options_1.NodePackageName,
            create: () => Promise.resolve(() => {
                return new Promise((res) => {
                    if (!this.nodeInstallLogPrinted) {
                        logger.warn(`An installation of node_modules has been required. Make sure to run it after the migration`);
                        this.nodeInstallLogPrinted = true;
                    }
                    res();
                });
            }),
        });
        this.registerTaskExecutor(node_3.BuiltinTaskExecutor.RunSchematic);
    }
    _resolveCollectionPath(name) {
        let collectionPath = undefined;
        if (name.startsWith('.') || name.startsWith('/')) {
            name = path_1.resolve(name);
        }
        if (path_1.extname(name)) {
            collectionPath = require.resolve(name);
        }
        else {
            const packageJsonPath = require.resolve(path_1.join(name, 'package.json'));
            // eslint-disable-next-line @typescript-eslint/no-var-requires
            const packageJson = require(packageJsonPath);
            let pkgJsonSchematics = packageJson['nx-migrations'];
            if (!pkgJsonSchematics) {
                pkgJsonSchematics = packageJson['ng-update'];
                if (!pkgJsonSchematics) {
                    throw new Error(`Could not find migrations in package: "${name}"`);
                }
            }
            if (typeof pkgJsonSchematics != 'string') {
                pkgJsonSchematics = pkgJsonSchematics.migrations;
            }
            collectionPath = path_1.resolve(path_1.dirname(packageJsonPath), pkgJsonSchematics);
        }
        try {
            if (collectionPath) {
                JSON.parse(stripJsonComments(fs_1.readFileSync(collectionPath).toString()));
                return collectionPath;
            }
        }
        catch (e) {
            throw new Error(`Invalid migration file in package: "${name}"`);
        }
        throw new Error(`Collection cannot be resolved: "${name}"`);
    }
}
class MigrationsWorkflow extends workflow_1.BaseWorkflow {
    constructor(host, logger) {
        super({
            host,
            engineHost: new MigrationEngineHost(logger),
            force: true,
            dryRun: false,
        });
    }
}
class NxScopedHost extends core_1.virtualFs.ScopedHost {
    constructor(root) {
        super(new node_2.NodeJsSyncHost(), root);
    }
    read(path) {
        if (this.isWorkspaceConfig(path)) {
            return this.isNewFormat().pipe(operators_1.switchMap((newFormat) => {
                if (newFormat) {
                    return super.read(path).pipe(operators_1.map((r) => {
                        try {
                            const w = JSON.parse(Buffer.from(r).toString());
                            const formatted = workspace_1.toOldFormatOrNull(w);
                            return formatted
                                ? Buffer.from(JSON.stringify(formatted, null, 2))
                                : r;
                        }
                        catch (e) {
                            return r;
                        }
                    }));
                }
                else {
                    return super.read(path);
                }
            }));
        }
        else {
            return super.read(path);
        }
    }
    write(path, content) {
        if (this.isWorkspaceConfig(path)) {
            return this.isNewFormat().pipe(operators_1.switchMap((newFormat) => {
                if (newFormat) {
                    try {
                        const w = JSON.parse(Buffer.from(content).toString());
                        const formatted = workspace_1.toNewFormatOrNull(w);
                        if (formatted) {
                            return super.write(path, Buffer.from(JSON.stringify(formatted, null, 2)));
                        }
                        else {
                            return super.write(path, content);
                        }
                    }
                    catch (e) {
                        return super.write(path, content);
                    }
                }
                else {
                    return super.write(path, content);
                }
            }));
        }
        else {
            return super.write(path, content);
        }
    }
    isWorkspaceConfig(path) {
        const p = path.toString();
        return (p === 'angular.json' ||
            p === '/angular.json' ||
            p === 'workspace.json' ||
            p === '/workspace.json');
    }
    isNewFormat() {
        return super.exists('/angular.json').pipe(operators_1.switchMap((isAngularJson) => {
            return super
                .read((isAngularJson ? '/angular.json' : '/workspace.json'))
                .pipe(operators_1.map((r) => JSON.parse(Buffer.from(r).toString()).version === 2));
        }));
    }
}
exports.NxScopedHost = NxScopedHost;
/**
 * This host contains the workaround needed to run Angular migrations
 */
class NxScopedHostForMigrations extends NxScopedHost {
    constructor(root) {
        super(root);
    }
    read(path) {
        return this.hasWorkspaceJson().pipe(operators_1.concatMap((hasWorkspace) => {
            if (this.isWorkspaceConfig(path)) {
                if (hasWorkspace &&
                    (path == '/angular.json' || path == 'angular.json')) {
                    return super
                        .read('/workspace.json')
                        .pipe(operators_1.map(processConfigWhenReading));
                }
                else {
                    return super.read(path).pipe(operators_1.map(processConfigWhenReading));
                }
            }
            else {
                return super.read(path);
            }
        }));
    }
    isFile(path) {
        return this.hasWorkspaceJson().pipe(operators_1.concatMap((hasWorkspace) => {
            if (hasWorkspace &&
                (path == '/angular.json' || path == 'angular.json')) {
                return super.isFile('/workspace.json');
            }
            else {
                return super.isFile(path);
            }
        }));
    }
    exists(path) {
        return this.hasWorkspaceJson().pipe(operators_1.concatMap((hasWorkspace) => {
            if (hasWorkspace &&
                (path == '/angular.json' || path == 'angular.json')) {
                return super.exists('/workspace.json');
            }
            else {
                return super.exists(path);
            }
        }));
    }
    write(path, content) {
        return this.hasWorkspaceJson().pipe(operators_1.concatMap((hasWorkspace) => {
            if (this.isWorkspaceConfig(path)) {
                if (hasWorkspace &&
                    (path == '/angular.json' || path == 'angular.json')) {
                    return super.write('/workspace.json', processConfigWhenWriting(content));
                }
                else {
                    return super.write(path, processConfigWhenWriting(content));
                }
            }
            else {
                return super.write(path, content);
            }
        }));
    }
    hasWorkspaceJson() {
        return super.exists('/workspace.json');
    }
}
exports.NxScopedHostForMigrations = NxScopedHostForMigrations;
function processConfigWhenReading(content) {
    try {
        const json = JSON.parse(Buffer.from(content).toString());
        Object.values(json.projects).forEach((p) => {
            try {
                Object.values(p.architect || p.targets).forEach((e) => {
                    if ((e.builder === '@nrwl/jest:jest' ||
                        e.executor === '@nrwl/jest:jest') &&
                        !e.options.tsConfig) {
                        e.options.tsConfig = `${p.root}/tsconfig.spec.json`;
                    }
                });
            }
            catch (e) { }
        });
        return Buffer.from(JSON.stringify(json, null, 2));
    }
    catch (e) {
        return content;
    }
}
function processConfigWhenWriting(content) {
    try {
        const json = JSON.parse(Buffer.from(content).toString());
        Object.values(json.projects).forEach((p) => {
            try {
                Object.values(p.architect || p.targets).forEach((e) => {
                    if ((e.builder === '@nrwl/jest:jest' ||
                        e.executor === '@nrwl/jest:jest') &&
                        e.options.tsConfig) {
                        delete e.options.tsConfig;
                    }
                });
            }
            catch (e) { }
        });
        return Buffer.from(JSON.stringify(json, null, 2));
    }
    catch (e) {
        return content;
    }
}
function generate(root, opts, verbose) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const logger = exports.getLogger(verbose);
        const fsHost = new NxScopedHost(core_1.normalize(root));
        const workflow = createWorkflow(fsHost, root, opts);
        const collection = getCollection(workflow, opts.collectionName);
        const schematic = collection.createSchematic(opts.generatorName, true);
        return (yield runSchematic(root, workflow, logger, Object.assign(Object.assign({}, opts), { generatorName: schematic.description.name }), schematic)).status;
    });
}
exports.generate = generate;
function runMigration(root, collection, schematic, isVerbose) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const logger = exports.getLogger(isVerbose);
        const host = new NxScopedHostForMigrations(core_1.normalize(root));
        const workflow = new MigrationsWorkflow(host, logger);
        return workflow
            .execute({
            collection,
            schematic,
            options: {},
            debug: false,
            logger: logger,
        })
            .toPromise();
    });
}
exports.runMigration = runMigration;
function wrapAngularDevkitSchematic(collectionName, generatorName) {
    return (host, generatorOptions) => tslib_1.__awaiter(this, void 0, void 0, function* () {
        const emptyLogger = {
            log: (e) => { },
            info: (e) => { },
            warn: (e) => { },
            error: (e) => { },
            fatal: (e) => { },
        };
        emptyLogger.createChild = () => emptyLogger;
        const recorder = (event) => {
            const eventPath = event.path.startsWith('/')
                ? event.path.substr(1)
                : event.path;
            if (event.kind === 'error') {
            }
            else if (event.kind === 'update') {
                host.write(eventPath, event.content);
            }
            else if (event.kind === 'create') {
                host.write(eventPath, event.content);
            }
            else if (event.kind === 'delete') {
                host.delete(eventPath);
            }
            else if (event.kind === 'rename') {
                host.rename(eventPath, event.to);
            }
        };
        const fsHost = new NxScopedHost(core_1.normalize(host.root));
        yield Promise.all(host.listChanges().map((c) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (c.type === 'CREATE' || c.type === 'UPDATE') {
                yield fsHost.write(c.path, c.content).toPromise();
            }
            else {
                yield fsHost.delete(c.path).toPromise();
            }
        })));
        const options = {
            generatorOptions: Object.assign(Object.assign({}, generatorOptions), { _: [] }),
            dryRun: true,
            interactive: false,
            help: false,
            debug: false,
            collectionName,
            generatorName,
            force: false,
            defaults: false,
        };
        const workflow = createWorkflow(fsHost, host.root, options);
        const collection = getCollection(workflow, collectionName);
        const schematic = collection.createSchematic(generatorName, true);
        const res = yield runSchematic(host.root, workflow, emptyLogger, options, schematic, false, recorder);
        if (res.status !== 0) {
            throw new Error(res.loggingQueue.join('\n'));
        }
    });
}
exports.wrapAngularDevkitSchematic = wrapAngularDevkitSchematic;
function invokeNew(root, opts, verbose) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const logger = exports.getLogger(verbose);
        const fsHost = new NxScopedHost(core_1.normalize(root));
        const workflow = createWorkflow(fsHost, root, opts);
        const collection = getCollection(workflow, opts.collectionName);
        const schematic = collection.createSchematic('new', true);
        return (yield runSchematic(root, workflow, logger, Object.assign(Object.assign({}, opts), { generatorName: schematic.description.name }), schematic)).status;
    });
}
exports.invokeNew = invokeNew;
let logger;
exports.getLogger = (isVerbose = false) => {
    if (!logger) {
        logger = node_2.createConsoleLogger(isVerbose, process.stdout, process.stderr, {
            warn: (s) => chalk.bold(chalk.yellow(s)),
            error: (s) => {
                if (s.startsWith('NX ')) {
                    return `\n${logger_1.NX_ERROR} ${chalk.bold(chalk.red(s.substr(3)))}\n`;
                }
                return chalk.bold(chalk.red(s));
            },
            info: (s) => {
                if (s.startsWith('NX ')) {
                    return `\n${logger_1.NX_PREFIX} ${chalk.bold(s.substr(3))}\n`;
                }
                return chalk.white(s);
            },
        });
    }
    return logger;
};
//# sourceMappingURL=ngcli-adapter.js.map